from os.path import isfile, join
from substrateinterface import Keypair, SubstrateInterface

TIME_UNIT = 10**9
AZERO = 10**12


def check_url(url):
    """Make sure that the provided WebSocket address is legit. Resolve shortcut aliases."""
    aliases = {
        'testnet': 'wss://ws.test.azero.dev',
        'mainnet': 'wss://ws.azero.dev',
        'local': 'ws://127.0.0.1:9944'
    }
    address = aliases.get(url, url)
    if not address.startswith(('wss://', 'ws://')):
        raise ValueError(f'Invalid WebSocket URL: {url}')
    return address


def check_file(*path):
    """Make sure file exists."""
    path = join(*path)
    if not isfile(path):
        raise ValueError(f'File does not exist: {path}')
    return path


def check_address(account_id, chain):
    """Make sure that provided AccountIds are correct."""
    if not chain.is_valid_ss58_address(account_id):
        raise ValueError(f'Invalid AccountId: {account_id}')
    return account_id


def weight(extrinsic_receipt):
    return extrinsic_receipt.weight["ref_time"] / TIME_UNIT


def fee(extrinsic_receipt):
    return extrinsic_receipt.total_fee_amount / AZERO


def call_contract(contract, keypair, method, args, value=0, gas_factor=1.01):
    """Simple wrapper which mimics ContractInstance.exec() with no gas limit, but relaxes the gas estimate returned from dry-run by `gas_factor`."""
    gas_limit = contract.read(keypair=keypair, method=method, args=args, value=value).gas_required
    gas_limit['ref_time'] = int(gas_factor * gas_limit['ref_time'])
    return contract.exec(keypair=keypair, method=method, args=args, value=value, gas_limit=gas_limit)


def build_contract_call(contract, keypair, method, args, value=0, gas_factor=1.05):
    gas_limit = contract.read(keypair=keypair, method=method, args=args, value=value).gas_required
    gas_limit['ref_time'] = int(gas_factor * gas_limit['ref_time'])
    data = contract.metadata.generate_message_data(name=method, args=args)
    return contract.substrate.compose_call(call_module='Contracts', call_function='call', call_params={
        'dest': contract.contract_address,
        'value': value,
        'gas_limit': gas_limit,
        'storage_deposit_limit': None,
        'data': data.to_hex()
    })


def send_single_call(call, chain, keypair, wait=True):
    extrinsic = chain.create_signed_extrinsic(call=call, keypair=keypair)
    return chain.submit_extrinsic(extrinsic, wait_for_inclusion=wait)


def send_batch(calls, chain, keypair, wait=True):
    batch = chain.compose_call(call_module='Utility', call_function='batch', call_params={'calls': calls})
    extrinsic = chain.create_signed_extrinsic(call=batch, keypair=keypair)
    return chain.submit_extrinsic(extrinsic, wait_for_inclusion=wait)


def fund_traders(chain_url, n_traders, balance, stash_phrase, trader_phrase):
    """Send `balance` native coins from an account generated by `stash_phrase` to `n_traders` accounts generated by `trader_phrase`.
    Funded accounts are: trader_phrase//0, trader_phrase//1, ... , trader_phrase//(n_traders-1)
    """
    stash_keypair = Keypair.create_from_uri(stash_phrase)
    chain = SubstrateInterface(url=check_url(chain_url))
    calls = []
    for i in range(n_traders):
        trader_addr = Keypair.create_from_uri(f'{trader_phrase}//{i}').ss58_address
        call = chain.compose_call(call_module='Balances', call_function='transfer_keep_alive', call_params={'dest': trader_addr, 'value': balance * AZERO})
        calls.append(call)

    receipt = send_batch(calls, chain, stash_keypair)
    if not receipt.is_success:
        print(f'Error in batch transfer: {receipt.error_message["docs"]}')
